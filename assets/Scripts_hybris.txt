[framework]
python : 3.5.2
tkinter : 8.6
pyinstaller : 3.2

[package]
name : RaConverter
version : 1.1.2
last_modified : 2017-05-22
author : Henrik Sejersen
email : mail@henriksejersen.com
description : Convert data files from statistical software packages to delivery files "Bilag 9"

[diverse]
main : __main__
font_option : *font
font : TkDefaultFont 12
resize_x : 0
resize_y : 0
side_top : top
side_left : left
side_right : right
fill_x : x
expand_yes : yes
anchor_east : e
anchor_west : w
relief_flat : flat
relief_solid : solid
tearoff : 0
underline : 0
state_enable : normal
state_disable : disable
read_mode : r
write_mode : w
wrap : word
index_start0 : 0
index_start1 : 1.0
index_end : end
new_line :
black : black
white : white
insert : insert
offset : +%d+%d
utf8 : utf-8
utf8_no_bom : utf-8-sig
strict : strict
io_error : I/O error({0}): {1}
windows_separator : \
unix_separator : /
windows_os : Windows

[program]
stata_name : Stata
stata_syntax : .do
stata_data : .dta
sas_name : SAS
sas_syntax : .sas
sas_data : .sas7bdat
sas_catalog : .sas7bcat
spss_name : SPSS
spss_syntax : .sps
spss_data : .sav
valid_extensions : ${program:stata_data} ${program:sas_data} ${program:spss_data}

[main_application]
button_height2 : 2
button_frame_padx10 : 10
button_frame_pady7 : 7
button_pady3 : 3
main_title : Create Delivery Files
menu_raconverter : RaConverter
sub_menu_about : About
sub_menu_exit : Exit
about_raconverter : About
missing_catalog : Missing Catalog File
data_file_information : Data File Information
button_step1 : Step 1:
               Select Data File
button_step2 : Step 2:
               Create Syntax
button_step3 : Step 3:
               Add Data File Info
button_step4 : Step 4:
               Create Output
about_message : ${package:name} v${package:version} (${package:last_modified})
                ${package:description}
missing_catalog_message : An expected ${program:sas_name} catalog file was not found. Is this intentional?
intro_text : Welcome to RaConverter!

             This program guides you through four steps that will convert a data file from ${program:stata_name}, ${program:sas_name} or ${program:spss_name} to the requested delivery files:

             Step 1. Identify your data file
             Step 2. Create and execute a syntax file
             Step 3. Add data file information
             Step 4. Create the delivery files
missing_catalog_text : Step 1 cancelled!

                       The SAS catalog is either missing or not properly named

                       Instructions:
                       1. Create a copy of your ${program:sas_name} catalog file here: "{0}"
                       2. Rename the catalog file to: "{1}${program:sas_catalog}"
                       3. Start over

                       Note:
                       The link between variable and format must be stored in the data file through a ${program:sas_name} data step
                       The catalog file must only contain formats (code lists) used by the selected data file
step1_invalid_text : Error!

                     Invalid file extension: "*{0}"

                     Supported file extensions:
                     "*${program:stata_data}"
                     "*${program:sas_data}"
                     "*${program:spss_data}"
step1_true_text : Step 1 completed!

                  Path to the data file directory: "{0}"
                  Name of the data file: "{1}"
step2_true_text : Step 2 completed!

                  Syntax file stored in: "{0}"
                  Syntax file name: "{1}{2}"

                  Instructions:
                  1. Leave this program running in the background
                  2. Open {3} and execute all lines of "{1}{2}"
                  3. Complete the final steps in this program after the syntax has been successfully executed
step3_true_text : Step 3 completed!

                  Valid entries (including empty entries) will be added to the appropriate delivery file
step4_true_text : Step 4 completed!

                  The delivery files are stored in: "{0}"

                  Metadata file: "{1}${metadata_file:metadata}"
                  Data file: "{1}${metadata_file:data}"

                  Please note:
                  Open the delivery files and check that all characters are presented correctly on the screen. If some characters are incorrect, open your data file in {2} and change the input character encoding

[entry_form]
label_width17 : 17
label_width21 : 21
entry_width36 : 36
text_entry_width46 : 46
text_entry_height16 : 16
button_height1 : 1
button_frame_padx7 : 7
button_frame_pady10 : 10
button_padx3 : 3
entry_frame_padx10 : 10
entry_frame_pady5 : 5
text_entry_padx10 : 10
enter_event : <Enter>
leave_event : <Leave>
button_press_event : <ButtonPress>
data_file_form_title : Add Data File Information
reference_form_title : Add Data File Reference(s)
menu_add_data_file_reference : Add Data File Reference(s)
data_file_name : Data File Name
data_file_description : Data File Description
key_variable : Key Variable(s)
variable_other : Variable(s) Other Data File
variable_this : Variable(s) This Data File
data_file_reference : Data File Reference
validate : focus
entry_string : %P
entry_name : %W
invalid_name : Invalid Name
ask_add_data_file_reference : Add Data File Reference(s)
button_add : Add
button_done : Done
button_quit : Quit
double_quote_both_variables : '{0} "{1}" "{2}"'
double_quote_variable_other : '{0} "{1}" {2}'
double_quote_variable_this : '{0} {1} "{2}"'
double_quote_no_variables : '{0} {1} {2}'
invalid_data_file_name_message : Please add a data file name!
invalid_variable_name_message : Please add at least one variable name!
add_data_file_reference_message : Add another data file reference?
invalid_name_message : The name must:
                       1. Start with a letter
                       2. Contain word characters only
                       3. Have maximum 128 characters
ask_add_data_file_reference_message : Do you wish to add one or more data file references?

[tooltip]
offset_x : 25
offset_y : 20
wait_time : 500
wrap_length : 280
label_ipadx1 : 1
tooltip_borderwidth : 1
default_tooltip_text : Tooltip
data_file_name_tooltip : The name of the data file
data_file_description_tooltip : An accurate description of the data file's content and usage
key_variable_tooltip : The name of the key variable(s). Separate multiple variable names with a space
variable_other_tooltip : The name of the key variable(s) in the referenced data file (primary key). Separate multiple variable names with a space
variable_this_tooltip : The name of the variable(s) in this data file (foreign key). Separate multiple variable names with a space

[metadata_file]
data : .csv
metadata : .txt
decoding_error_directory : decoding_error
application_name_label : SYSTEMNAVN
data_file_information_label : DATAFILINFORMATION
data_file_name_label : DATAFILNAVN
data_file_description_label : DATAFILBESKRIVELSE
key_variable_label : NÃ˜GLEVARIABEL
data_file_reference_label : REFERENCE
variable_list_label : VARIABEL
variable_description_label : VARIABELBESKRIVELSE
code_list_label : KODELISTE
user_defined_missing_value_label : BRUGERKODE
data_file_information_file : _TABELINFORMATION${metadata_file:metadata}
variable_list_file : _VARIABEL${metadata_file:metadata}
variable_description_file : _VARIABELBESKRIVELSE${metadata_file:metadata}
code_list_file : _KODELISTE${metadata_file:metadata}
user_defined_missing_value_file : _BRUGERKODE${metadata_file:metadata}
invalid_encoding_text : NB! File ignored because of decoding error: {0}
no_metadata_text : No metadata created for label: {0}

[syntax_file]
dollar_sign : $$
stata_syntax_content : /*
                       Version: 1.0
                       Encoding: UTF-8 without byte order mark
                       Note: The working directory must contain the data file (dta)
                       */

                       * Set the working directory and data file name
                       global fileDir "{1}"
                       global inputStata {3}fileDir{0}{2}
                       global inputStata_ "{2}"

                       * Set options
                       set scrollbufsize 2048000
                       set linesize 255
                       set more off

                       * Set end of line character(s)
                       if regexm(c(os),"Windows")==1 {
                       global osEOL="\W"
                       }
                       else if regexm(c(os),"Mac")==1 {
                       global osEOL="\M"
                       }
                       else if regexm(c(os),"Unix")==1 {
                       global osEOL="\U"
                       }

                       * Escape reserved xml characters
                       capture program drop clean
                       program define clean
                       filefilter {3}fileDir{0}temp.txt {3}fileDir{0}tempA.txt, from ("\038d") to ("&amp;") replace
                       filefilter {3}fileDir{0}tempA.txt {3}fileDir{0}tempB.txt, from ("\060d") to ("<") replace
                       filefilter {3}fileDir{0}tempB.txt {3}fileDir{0}tempC.txt, from ("\062d") to (">") replace
                       filefilter {3}fileDir{0}tempC.txt {3}fileDir{0}tempD.txt, from ("\039d") to ("&apos;") replace
                       filefilter {3}fileDir{0}tempD.txt {3}fileDir{0}tempE.txt, from ("\034d") to ("&quot;") replace
                       end

                       * CREATE VARIABEL
                       use {3}inputStata, replace
                       foreach var of varlist _all {
                       label var `var\' ""
                       }
                       cls
                       describe _all
                       translate @Results {3}fileDir{0}temp.txt, replace
                       clean
                       * Import file and extract code list name (value label)
                       * Note: Variable name and format can be truncated in the input
                       * Note: Use the format statement to get the full length of variable name and format
                       import delimited v1 using {3}fileDir{0}tempE.txt, clear ///
                       delimiter("\t") stringcols(_all) encoding("utf-8")
                       replace v1=regexr(v1,"\* {3}","")
                       drop if v1=="" | regexm(v1,"^.+[ ].+[ ]%.+[ ]*")==0
                       replace v1=trim(stritrim(v1))
                       split v1, gen(var)
                       capture confirm string variable var4
                       if _rc {
                       gen var4=""
                       }
                       keep var4
                       rename var4 var3
                       gen v1=_n
                       save {3}fileDir{0}valLabelName, replace
                       * Make new dataset
                       use {3}inputStata, replace
                       cls
                       format _all
                       translate @Results {3}fileDir{0}temp.txt, replace
                       clean
                       * Import file and extract variable name and format
                       import delimited v1 v2 using {3}fileDir{0}tempE.txt, clear ///
                       delimiter("%") stringcols(_all) encoding("utf-8")
                       replace v1=trim(v1)
                       drop if v2==""
                       replace v2="%"+trim(v2)
                       gen var1=v1
                       gen var2=v2
                       drop v1 v2
                       gen v1=_n
                       order v1 var1 var2
                       save {3}fileDir{0}varNameFormat, replace
                       * Create output with variable name and format
                       merge 1:1 v1 using {3}fileDir{0}valLabelName, nogenerate
                       drop v1
                       replace var2=var3+"." if var3!=""
                       gen var=var1+" "+var2
                       drop var1 var2 var3
                       * Write output to file
                       export delimited using {3}fileDir{0}tempB.txt, delimiter(",") novarnames nolabel replace
                       filefilter {3}fileDir{0}tempB.txt {3}fileDir{0}{2}_VARIABEL.txt, from(",{3}osEOL") to ("") replace

                       * CREATE VARIABELBESKRIVELSE
                       use {3}inputStata, replace
                       * Strip all value labels
                       _strip_labels _all
                       cls
                       describe _all
                       translate @Results {3}fileDir{0}temp.txt, replace
                       clean
                       * Import file and extract variable name and description
                       import delimited v1 using {3}fileDir{0}tempE.txt, clear ///
                       delimiter("\t") stringcols(_all) encoding("utf-8")
                       * Handle broken line in description
                       replace v1=v1+" ...NB! LABEL TRUNCATED BY INVALID LINE FEED..." if regexm(v1[_n+1],"^[ ][ ][ ]+")==0
                       replace v1=trim(stritrim(v1))
                       drop if v1=="" | regexm(v1,"^.+[ ].+[ ]%.+[ ]*")==0
                       split v1, gen(var) limit(4)
                       replace var4="" if var4!="*"
                       gen v0=length(var1+var2+var3+var4)+4
                       gen varLabel=substr(v1,v0,.)
                       replace varLabel=trim(varLabel)
                       keep varLabel
                       gen v1=_n
                       * Create output with variable name and description
                       merge 1:1 v1 using {3}fileDir{0}varNameFormat, nogenerate
                       * If label is empty, use default value
                       replace varLabel="n.a." if varLabel==""
                       gen v0=var1+" '"+varLabel+"'"
                       keep v0
                       * Write output to file
                       export delimited using {3}fileDir{0}{2}_VARIABELBESKRIVELSE.txt, delimiter(tab) novarnames nolabel replace

                       * CREATE KODELISTE
                       use {3}inputStata, replace
                       cls
                       label list
                       translate @Results {3}fileDir{0}temp.txt, replace
                       clean
                       * Import file and extract variable name, value, and value label
                       import delimited v1 using {3}fileDir{0}tempE.txt, clear ///
                       delimiter("\t") stringcols(_all) encoding("utf-8")
                       * Handle broken line in label
                       replace v1=v1+" ...NB! LABEL TRUNCATED BY INVALID LINE FEED..." if regexm(v1[_n+1],"^[ ][ ][ ]+")==0
                       drop if regexm(v1,"^[ ]+.*:{3}")==0 & regexm(v1,"^[ ]+([0-9]+|\.[a-z])[ ].*{3}")==0
                       replace v1=trim(stritrim(v1))
                       drop if v1==""
                       drop if regexm(v1,"2[ ]+\.[ ]+translate")>0 | regexm(v1,"1[ ]+\.[ ]+label list")>0
                       * If value label(s) exist, create output with code list(s)
                       if _N!=0 {
                       split v1, gen(var) limit(1)
                       gen v0=length(var1)+2
                       gen onlyLabel=substr(v1,v0,.)
                       replace var1=regexr(var1,":{3}","")
                       gen valLabel=var1 if onlyLabel==""
                       replace var1="" if onlyLabel==""
                       replace var1="'"+var1+"'" if var1!=""
                       replace onlyLabel="'"+onlyLabel+"'" if onlyLabel!=""
                       replace valLabel=var1+" "+onlyLabel if valLabel==""
                       keep valLabel
                       * Write output to file
                       export delimited using {3}fileDir{0}{2}_KODELISTE.txt, delimiter(tab) novarnames nolabel replace
                       }
                       else {
                       cls
                       display in red "Note: No value labels found"
                       }

                       * Delete temporary files on disk
                       erase {3}fileDir{0}temp.txt
                       erase {3}fileDir{0}tempA.txt
                       erase {3}fileDir{0}tempB.txt
                       erase {3}fileDir{0}tempC.txt
                       erase {3}fileDir{0}tempD.txt
                       erase {3}fileDir{0}tempE.txt
                       erase {3}fileDir{0}valLabelName.dta
                       erase {3}fileDir{0}varNameFormat.dta

                       /*
                       CONVERT DATA TO DELIMITED TEXT FILE
                       Note: Write variable names on the first line
                       Note: Write text qualifier only if data contain the delimiter
                       Note: Escape a double quote in string data with a double quote and double quoting of the whole string
                       Note: Null values in numeric variables are not respresented at all
                       Note: Special codes for missing values are written as lowercase letters with a preceding dot (.a-.z)
                       */
                       use {3}inputStata, clear
                       export delimited using {3}fileDir{0}{3}inputStata_.csv, delimiter(";") nolabel replace
sas_syntax_content_with_catalog : /*
                                  Version: 1.0
                                  Encoding: UTF-8 without byte order mark
                                  Note: The working directory must contain the data file (sas7bdat) and catalog file (sas7bcat)
                                  NB: The data and catalog files must have the same name
                                  NB: The link between variable and format must be stored in the data file
                                  NB: The formats in the catalog file must represent code list(s) only
                                  NB: The values in the catalog file must be explicitly specified (ranges are invalid)
                                  */

                                  * Set the working directory and data file name;
                                  %let outDir=%str({1}{0});
                                  %let inputSas=%str({2});
                                  libname mylib "&outDir";

                                  * Set options;
                                  options locale=da_DK replace=yes;
                                  options nofmterr;

                                  * Escape reserved xml characters;
                                  %macro clean(varName);
                                  &varname=strip(&varname);
                                  label=tranwrd(&varName,'&','&amp;');
                                  label=tranwrd(&varName,'<','<');
                                  label=tranwrd(&varName,'>','>');
                                  label=tranwrd(&varName,"'",'&apos;');
                                  label=tranwrd(&varName,'"','&quot;');
                                  %mend clean;

                                  * CREATE VARIABEL;
                                  ods listing;
                                  ods trace on /listing;
                                  * Ods output <ouput-object>=<sas data set>;
                                  ods output variables=mylib.odsOut;
                                  proc contents data=mylib.&inputSas;
                                  run;
                                  ods trace off;
                                  ods _all_ close;
                                  * If format column is missing in output, add column;
                                  data mylib.odsOut;
                                  length Format {3}200;
                                  set mylib.odsOut;
                                  id=open('mylib.odsOut');
                                  if varnum(id, 'Format')=0 then Format='';
                                  rc=close(id);
                                  drop rc id;
                                  run;
                                  * Create output with variable name and format;
                                  data mylib.varNames(keep=varNameFormat);
                                  set mylib.odsOut;
                                  format Format {3}char200.;
                                  *If format is missing, map the generic type to format;
                                  if lowcase(type) eq 'num' then type='';
                                  else
                                  do;
                                  if lowcase(type) EQ 'char' then type='{3}';
                                  end;
                                  if Format eq '' then Format=cats(type,len,'.');
                                  * If present in format, remove "char" and "best";
                                  if prxmatch('/\{3}char\d+\./',lowcase(strip(Format)))>0 then Format=cats(type,len,'.');
                                  if prxmatch('/best\d*\./',lowcase(strip(Format)))>0 then Format=cats(type,len,'.');
                                  varNameFormat=cat(strip(Variable),' ',strip(lowcase(Format)));
                                  run;
                                  * Write output to file;
                                  %let name=%str({2}_VARIABEL.txt);
                                  %let outfile=&outDir&name;
                                  data _null_;
                                  set mylib.varNames;
                                  file "&outfile" encoding='utf-8' dsd dlm='09'x lrecl=2000000;
                                  put(_all_)(+0);
                                  run;

                                  * CREATE VARIABELBESKRIVELSE;
                                  data mylib.varLabels(keep=varLabels);
                                  length Label {3}6400;
                                  set mylib.odsOut;
                                  %clean(Label);
                                  if Label eq '' then Label='n.a.';
                                  length varLabels {3}7200;
                                  varLabels=cat(strip(Variable)," '",strip(Label),"'");
                                  run;
                                  * Write output to file;
                                  %let name=%str({2}_VARIABELBESKRIVELSE.txt);
                                  %let outfile=&outDir&name;
                                  data _null_;
                                  set mylib.varLabels;
                                  file "&outfile" encoding='utf-8' dsd dlm='09'x lrecl=2000000;
                                  put(_all_)(+0);
                                  run;

                                  * CREATE KODELISTE;
                                  %let name=%str(valLabels);
                                  %let outfile=&outDir&name;
                                  * Get content from the catalog file;
                                  proc format out="&outfile" fmtlib library=mylib.&inputSas;
                                  run;
                                  data mylib.valLabels(keep=Fmtname valLabels);
                                  length Label {3}32767;
                                  set mylib.valLabels;
                                  %clean(Label);
                                  * If label is empty, use default value;
                                  if Label eq '' then Label='n.a.';
                                  Fmtname=strip(lowcase(Fmtname));
                                  if lag(Fmtname)=Fmtname then Fmtname='';
                                  * Remove preceding dot in front of special values (.A-.Z);
                                  if prxmatch('/\.[a-z]/',lowcase(strip(Start)))>0 then Start=substr(strip(Start),2,1);
                                  length valLabels {3}32767;
                                  valLabels=cat("'",strip(Start),"'"," '",strip(Label),"'");
                                  run;
                                  * Create output with code list(s);
                                  %let name=%str({2}_KODELISTE.txt);
                                  %let outfile=&outDir&name;
                                  data _null_;
                                  set mylib.valLabels;
                                  file "&outfile" encoding='utf-8' dsd dlm='09'x lrecl=2000000;
                                  put(Fmtname)(+0);
                                  put(valLabels)(+0);
                                  run;
                                  data mylib.valLabels;
                                  infile "&outfile" encoding='utf-8' delimiter='09'x missover dsd lrecl=32767;
                                  informat var1 {3}32767.;
                                  format var1 {3}32767.;
                                  input var1 {3}; var1=strip(var1);
                                  run;
                                  data mylib.valLabels;
                                  set mylib.valLabels;
                                  if var1 eq '' then delete;
                                  run;
                                  * Write output to file;
                                  data _null_;
                                  set mylib.valLabels;
                                  file "&outfile" encoding='utf-8' dsd dlm='09'x lrecl=2000000;
                                  put(_all_)(+0);
                                  run;

                                  * Delete temporary files on disk;
                                  proc datasets library=mylib;
                                  delete odsOut varNames varLabels valLabels;
                                  run;

                                  /*
                                  CONVERT DATA TO DELIMITED TEXT FILE (DEFAULT METHOD)
                                  Note: Write variable names on the first line
                                  Note: Write text qualifier only if data contain the delimiter
                                  Note: Escape a double quote in string data with a double quote and double quoting of the whole string
                                  Note: Null values in numeric variables are not respresented at all
                                  Note: Special codes for missing values are written as uppercase letters (A-Z)
                                  NB: Max lrecl in output=32767
                                  */
                                  data _null_;
                                  call symput('datafile', "mylib.&inputSas");
                                  filename csv "&outDir{0}&inputSas..csv" encoding='utf-8';
                                  %let outFile=csv;
                                  proc export data=&datafile outfile=&outFile dbms=dlm replace;
                                  delimiter=';';
                                  putnames=yes;
                                  run;

                                  /*
                                  CONVERT DATA TO DELIMITED TEXT FILE (ALTERNATIVE METHOD)
                                  Note: Write text qualifier only if data contain the delimiter
                                  Note: Escape a double quote in string data with a double quote and double quoting of the whole string
                                  Note: Null values in numeric variables are not respresented at all
                                  Note: Special codes for missing values are written as uppercase letters (A-Z)
                                  NB: Does not write variable names on the first line
                                  data _null_;
                                  file csv dsd dlm=';' lrecl=2000000;
                                  set mylib.&inputName;
                                  put(_all_)(+0);
                                  run;
                                  */
sas_syntax_content_without_catalog : /*
                                     Version: 1.0
                                     Encoding: UTF-8 without byte order mark
                                     Note: The working directory must contain the data file (sas7bdat)
                                     */

                                     * Set the working directory and data file name;
                                     %let outDir=%str({1}{0});
                                     %let inputSas=%str({2});
                                     libname mylib "&outDir";

                                     * Set options;
                                     options locale=da_DK replace=yes;
                                     options nofmterr;

                                     * Escape reserved xml characters;
                                     %macro clean(varName);
                                     &varname=strip(&varname);
                                     label=tranwrd(&varName,'&','&amp;');
                                     label=tranwrd(&varName,'<','<');
                                     label=tranwrd(&varName,'>','>');
                                     label=tranwrd(&varName,"'",'&apos;');
                                     label=tranwrd(&varName,'"','&quot;');
                                     %mend clean;

                                     * CREATE VARIABEL;
                                     ods listing;
                                     ods trace on /listing;
                                     * Ods output <ouput-object>=<sas data set>;
                                     ods output variables=mylib.odsOut;
                                     proc contents data=mylib.&inputSas;
                                     run;
                                     ods trace off;
                                     ods _all_ close;
                                     * If format column is missing in output, add column;
                                     data mylib.odsOut;
                                     length Format {3}200;
                                     set mylib.odsOut;
                                     id=open('mylib.odsOut');
                                     if varnum(id, 'Format')=0 then Format='';
                                     rc=close(id);
                                     drop rc id;
                                     run;
                                     * Create output with variable name and format;
                                     data mylib.varNames(keep=varNameFormat);
                                     set mylib.odsOut;
                                     format Format {3}char200.;
                                     *If format is missing, map the generic type to format;
                                     if lowcase(type) eq 'num' then type='';
                                     else
                                     do;
                                     if lowcase(type) EQ 'char' then type='{3}';
                                     end;
                                     if Format eq '' then Format=cats(type,len,'.');
                                     * If present in format, remove "char" and "best";
                                     if prxmatch('/\{3}char\d+\./',lowcase(strip(Format)))>0 then Format=cats(type,len,'.');
                                     if prxmatch('/best\d*\./',lowcase(strip(Format)))>0 then Format=cats(type,len,'.');
                                     varNameFormat=cat(strip(Variable),' ',strip(lowcase(Format)));
                                     run;
                                     * Write output to file;
                                     %let name=%str({2}_VARIABEL.txt);
                                     %let outfile=&outDir&name;
                                     data _null_;
                                     set mylib.varNames;
                                     file "&outfile" encoding='utf-8' dsd dlm='09'x lrecl=2000000;
                                     put(_all_)(+0);
                                     run;

                                     * CREATE VARIABELBESKRIVELSE;
                                     data mylib.varLabels(keep=varLabels);
                                     length Label {3}6400;
                                     set mylib.odsOut;
                                     %clean(Label);
                                     if Label eq '' then Label='n.a.';
                                     length varLabels {3}7200;
                                     varLabels=cat(strip(Variable)," '",strip(Label),"'");
                                     run;
                                     * Write output to file;
                                     %let name=%str({2}_VARIABELBESKRIVELSE.txt);
                                     %let outfile=&outDir&name;
                                     data _null_;
                                     set mylib.varLabels;
                                     file "&outfile" encoding='utf-8' dsd dlm='09'x lrecl=2000000;
                                     put(_all_)(+0);
                                     run;

                                     * Delete temporary files on disk;
                                     proc datasets library=mylib;
                                     delete odsOut varNames varLabels valLabels;
                                     run;

                                     /*
                                     CONVERT DATA TO DELIMITED TEXT FILE (DEFAULT METHOD)
                                     Note: Write variable names on the first line
                                     Note: Write text qualifier only if data contain the delimiter
                                     Note: Escape a double quote in string data with a double quote and double quoting of the whole string
                                     Note: Null values in numeric variables are not respresented at all
                                     Note: Special codes for missing values are written as uppercase letters (A-Z)
                                     NB: Max lrecl in output=32767
                                     */
                                     data _null_;
                                     call symput('datafile', "mylib.&inputSas");
                                     filename csv "&outDir{0}&inputSas..csv" encoding='utf-8';
                                     %let outFile=csv;
                                     proc export data=&datafile outfile=&outFile dbms=dlm replace;
                                     delimiter=';';
                                     putnames=yes;
                                     run;

                                     /*
                                     CONVERT DATA TO DELIMITED TEXT FILE (ALTERNATIVE METHOD)
                                     Note: Write text qualifier only if data contain the delimiter
                                     Note: Escape a double quote in string data with a double quote and double quoting of the whole string
                                     Note: Null values in numeric variables are not respresented at all
                                     Note: Special codes for missing values are written as uppercase letters (A-Z)
                                     NB: Does not write variable names on the first line
                                     data _null_;
                                     file csv dsd dlm=';' lrecl=2000000;
                                     set mylib.&inputName;
                                     put(_all_)(+0);
                                     run;
                                     */
spss_syntax_content : */
                      Version: 1,0
                      Encoding: UTF-8 with byte order mark
                      Note: The working directory must contain the data file (sav)
                      */

                      * Set the working directory and data file name.
                      file handle dataDir
                      /name '{1}'.
                      file handle inputSpss
                      /name 'dataDir{0}{2}.sav'.

                      * Set options.
                      set unicode on decimal dot olang=english.

                      * Escape reserved xml characters.
                      define !clean(var=!tokens(1))
                      compute !var=ltrim(rtrim(!var)).
                      compute !var=replace(!var, '&', '&amp;').
                      compute !var=replace(!var, '<', '<').
                      compute !var=replace(!var, '>', '>').
                      compute !var=replace(!var, "'", '&apos;').
                      compute !var=replace(!var, '"', '&quot;').
                      !enddefine.

                      * Create dictionary file.
                      define !dictionary(subtype=!tokens(1))
                      get file 'inputSpss'.
                      oms
                      /select tables
                      /if subtypes=[!subtype]
                      /destination format=sav outfile='dataDir{0}dictionary.sav' viewer=no.
                      display dictionary.
                      omsend.
                      !enddefine.

                      * Create dummy variable with metadata.
                      get file 'inputSpss'.
                      compute absoluteDum=1.
                      alter type absoluteDum(f1).
                      variable labels absoluteDum 'Nothing'.
                      value labels absoluteDum 1 'Nothing'.
                      missing values absoluteDum(1).
                      save outfile 'inputSpss'.

                      * Create file with all code lists.
                      * NB: Dummy decimals are added to all code values, if a code value has decimals somewhere.
                      !dictionary subtype='variable values'.
                      get file 'dataDir{0}dictionary.sav'
                      /keep var1 var2 label
                      /rename var1=varName var2=val label=valLabel.
                      alter type varName(a64) val valLabel(a32767).
                      sort cases by varName val valLabel.
                      !clean var=val.
                      !clean var=valLabel.
                      alter type val valLabel(amin).
                      save outfile 'dataDir{0}code_lists.sav'.

                      * Map variable to code list.
                      get file 'dataDir{0}code_lists.sav'.
                      string compare(a32767).
                      compute casenum={3}casenum.
                      sort cases by varName.
                      compute rep=1.
                      * Count codes.
                      if lag(varName) eq varName rep=1+lag(rep).
                      sort cases by varName(d) rep(d).
                      compute codeCount=rep.
                      * Store maximum code count in variable.
                      if lag(varName) eq varName codeCount=lag(codeCount).
                      sort cases by varName val valLabel.
                      * Concatenate code and value.
                      compute compare=concat(val, valLabel).
                      compute lengthCompare=length(compare).
                      do if lag(varName) eq varName.
                      do if lag(compare)=''.
                      compute compare=''.
                      else.
                      compute lengthCompare=length(compare)+length(lag(compare)).
                      do if lengthCompare le 32767.
                      * Concatenate all codes and values into one string.
                      compute compare=concat(lag(compare), compare).
                      else.
                      compute compare=''.
                      end if.
                      end if.
                      end if.
                      execute.
                      * Select string to compare.
                      select if rep eq codeCount and compare ne ''.
                      execute.
                      * Link the unique code list to variables.
                      sort cases by compare.
                      string varName_(a64).
                      compute varName_=varName.
                      if lag(compare) eq compare varName_=lag(varName_).
                      alter type varName_(amin).
                      sort cases by varName.
                      save outfile 'dataDir{0}variable_to_code_list.sav'
                      /keep varName varName_.
                      execute.

                      * Remove redundant code lists.
                      match files file 'dataDir{0}code_lists.sav'
                      /table='dataDir{0}variable_to_code_list.sav'
                      /by varName.
                      compute keep=1.
                      if varName ne varName_ keep=0.
                      select if keep=1.
                      save outfile 'dataDir{0}unique_code_lists.sav'.

                      * CREATE VARIABEL.
                      !dictionary subtype='variable information'.
                      get file 'dataDir{0}dictionary.sav'
                      /keep var1 writeformat
                      /rename var1=varName writeformat=varFormat.
                      alter type varName(a64) varFormat(amin).
                      compute varFormat=lower(varFormat).
                      compute casenum={3}casenum.
                      sort cases by varName.
                      save outfile='dataDir{0}variable.sav'.
                      * Link variable to code list (if link exists).
                      get file 'dataDir{0}code_lists.sav'.
                      compute rep=1.
                      * Keep unique variable names.
                      if lag(varName)=varName rep=1+lag(rep).
                      select if rep eq 1.
                      sort cases by varName.
                      save outfile='dataDir{0}variable_has_code_list.sav'
                      /keep varName.
                      * Add code list reference to variable list.
                      match files file 'dataDir{0}variable.sav' /in=master
                      /file='dataDir{0}variable_has_code_list.sav' /in=codeVar
                      /file='dataDir{0}variable_to_code_list.sav' /in=codeListName
                      /by varName.
                      string type(a1) variable(a32767).
                      alter type varFormat(a66).
                      * If variable has a code list, overwrite variable format with variable or code list name.
                      compute type=char.substr(varFormat, 1, 1).
                      if codeVar eq 1 varFormat=concat(varName_, '.').
                      if codeVar eq 1 and type eq 'a' varFormat=concat('{3}', varFormat).
                      compute variable=concat(ltrim(rtrim(varName)), ' ', ltrim(rtrim(varFormat))).
                      sort cases by casenum.
                      select if varName ne 'absoluteDum'.
                      alter type variable(amin).
                      delete variables casenum varName varName_ type varFormat master codeVar codeListName.
                      * Note: Trailing spaces included in output lines.
                      write outfile 'dataDir{0}{2}_VARIABEL.txt' /variable.
                      execute.

                      * CREATE VARIABELBESKRIVELSE.
                      !dictionary subtype='variable information'.
                      get file 'dataDir{0}dictionary.sav'
                      /keep var1 label
                      /rename var1=varName label=varLabel.
                      alter type varName(a64) varLabel(a32767).
                      * If label is empty, use default value.
                      if varLabel='<none>' varLabel='n.a.'.
                      !clean var=varLabel.
                      alter type varLabel(amin).
                      string varDescription(a32767).
                      compute varDescription=concat(ltrim(rtrim(varName)), concat(" '", ltrim(rtrim(varLabel)), "'")).
                      select if varName ne 'absoluteDum'.
                      alter type varDescription(amin).
                      * Note: Trailing spaces included in output lines.
                      write outfile 'dataDir{0}{2}_VARIABELBESKRIVELSE.txt' /varDescription.
                      execute.

                      * CREATE KODELISTE.
                      get file 'dataDir{0}unique_code_lists.sav'.
                      string varRef codeList(a32767).
                      compute codeList=concat('"', "'", ltrim(rtrim(val)), "'", concat(" '", ltrim(rtrim(valLabel)), "'"), '"').
                      if lag(varName) ne varName varRef=concat('"', ltrim(rtrim(varName)), '"').
                      select if varName ne 'absoluteDum'.
                      alter type codeList varRef(amin).
                      write outfile 'dataDir{0}temp.txt' /1 varRef /2 codeList.
                      get data
                      /type=txt
                      /file='dataDir{0}temp.txt'
                      /arrangement=delimited
                      /delimiters=';'
                      /qualifier='"'
                      /variables=codeList A.
                      select if codeList ne ''.
                      alter type codeList(amin).
                      * Note: Trailing spaces included in output lines.
                      write outfile 'dataDir{0}{2}_KODELISTE.txt' /codeList.
                      execute.

                      * CREATE BRUGERKODE.
                      !dictionary subtype='variable information'.
                      get file 'dataDir{0}dictionary.sav'
                      /keep var1 missingvalues
                      /rename var1=varName missingvalues=missing.
                      alter type varName(a64) missing(amin).
                      sort cases by varName.
                      save outfile 'dataDir{0}user_defined_missing_values.sav'.
                      * Remove missing values from redundant code lists.
                      match files file 'dataDir{0}user_defined_missing_values.sav'
                      /file='dataDir{0}variable_to_code_list.sav'
                      /by varName.
                      compute keep=1.
                      if varName ne varName_ keep=0.
                      select if keep=1.
                      * Format user-defined missing values.
                      select if char.length(missing) gt 0.
                      compute missing=replace(missing, '"', '').
                      compute missing=replace(missing, ',', '').
                      !clean var=missing.
                      alter type missing(amin).
                      string varMissing(a32767).
                      compute varMissing=concat(ltrim(rtrim(varName)), " '", replace(ltrim(rtrim(missing)), ' ', "' '"), "'").
                      select if varName ne 'absoluteDum'.
                      alter type varMissing(amin).
                      * Note: Trailing spaces included in output lines.
                      write outfile 'dataDir{0}{2}_BRUGERKODE.txt' /varMissing.
                      execute.

                      * Delete temporary content (in file and on disk).
                      get file 'inputSpss'.
                      save outfile 'inputSpss'
                      /drop absoluteDum.
                      erase file='dataDir{0}dictionary.sav'.
                      erase file='dataDir{0}code_lists.sav'.
                      erase file='dataDir{0}variable_to_code_list.sav'.
                      erase file='dataDir{0}unique_code_lists.sav'.
                      erase file='dataDir{0}variable.sav'.
                      erase file='dataDir{0}variable_has_code_list.sav'.
                      erase file='dataDir{0}user_defined_missing_values.sav'.
                      erase file='dataDir{0}temp.txt'.
                      execute.

                      */
                      CONVERT DATA TO DELIMITED TEXT FILE
                      Note: Write variable names on the first line
                      Note: Write text qualifier only if data contain the delimiter
                      Note: Escape a double quote in string data with a double quote and double quoting of the whole string
                      Note: Null values in numeric variables are presented as space
                      Note: User-defined missing values are presented "as is" (either number or string value)
                      */

                      define !export(outfile=!tokens(1))
                      get file !QUOTE(!CONCAT(dataDir, '{0}', !outfile, '.sav')).
                      save translate outfile=!QUOTE(!CONCAT(dataDir, '{0}', !outfile, '.csv'))
                      /textoptions delimiter=';' qualifier='"' decimal=dot format=variable
                      /type=csv
                      /encoding='utf8'
                      /map
                      /replace
                      /fieldnames
                      /cells=values.
                      !enddefine.
                      !export outfile={2}.